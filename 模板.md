# 链表



#### 1. 链表套路

##### 1.1 快慢指针

###### (1)可以找到中点

```javascript
let fast = head;
let mid = head;
while(fast && fast.next){
    fast = fast.next.next;
    mid = mid.next;
}
if(fast){
    //奇数长度的链表
    mid = mid.next;
}
```

###### (2)可以判断链表是否存在环

```javascript
while (fast && fast.next) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast === slow) {
            return true;
        }
}
```



##### 1.2 哑巴节点使用场景：

当头结点不确定时

1. 头结点可能会被删除
2. 两个链表合并，不知道用哪个头结点

##### 1.3 逆序处理问题可以用栈



#### 2. 链表函数模板

##### 2.1  翻转链表

```javascript
// 迭代
var reverseList = function(head){
    if(!head||!head.next) return head;
	let cur = head.next;
	let tail = cur;
	head.next = null;
	while (cur) {
    	tail = cur.next;
    	cur.next = head;
    	head = cur;
    	cur = tail;
	}
	return head;
}
// 递归
var reverseList = function(head){
    if(!head||!head.next) return head;
	let next = head.next;
    let newHead = reverseList(next);
    head.next = null;
    next.next = head;
    return newHead;
}

```

##### 2.2 删除节点

```javascript
// 只需要找到待删节点的前一个就行，不需要设置额外的节点
// 用一个节点prev
prev.next = prev.next.next;
```

# 二叉树

#### 2.算法模板

##### 2.1 求树高

```javascript
var depth = function(root){
    if(!root) return 0;
    return Math.max(depth(root.left), depth(root.right))+1;
}
```

##### 2.2 二叉树的中序遍历（迭代）

```javascript
const stack = [];
while(root || stack.length){
    while(root){
        stack.push(root);
        root = root.left;
    }
    root = stack.pop();
    console.log(root.val);
    root = root.right;
}
```

##### 2.3 层次遍历

```javascript
const queue = [];
queue.push(root);
while(queue.length){
    root = queue.shift(); //一次处理一层： while(queue.length) root = queue.shift();
    if(root.left) queue.push(root.left);
    if(root.right) queue.push(root.right);
}
```

##### 2.4 二叉树的前序遍历（迭代）

```javascript
stack.push(root);
while (stack.length) {
    root = stack.pop();
    result.push(root.val);
    if (root.right) stack.push(root.right);
    if (root.left) stack.push(root.left);
}
return result;
```

##### 2.5 叶子节点的最近公共祖先

```javascript
if(!root) return null;
let diff = depth(root.left) - depth(root.right);
if (diff===0) {
	return root;
} else if(diff<0){
    return lcaDeepestLeaves(root.right);
} else {
    return lcaDeepestLeaves(root.left);
}
```



# 异或

#### 1. 异或的性质

(1) 任何数和0异或，结果是原来的数 a^0 = a

(2) 任何数和自身运算，结果是0   a^a = 0

(3) ^满足交换律和结合律

# 二分查找

#### 1. 算法模板

```javascript
if (!nums.length) return -1;
let low = 0, high = nums.length - 1, mid;
while (low <= high) {
   mid = Math.floor((low + high) / 2);
   if (nums[mid] === target) return mid;
   else if (nums[mid] < target) low = mid + 1;
   else high = mid - 1;
}
return -1; // 如果是找某一范围，返回high/low,看具体情况（能用二分的，应该也可以用双指针法）；

```

# 排序

#### 1. 算法模板

